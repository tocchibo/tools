<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Commands2Dot</title>
  <script src="https://unpkg.com/viz.js"></script>
  <script src="https://unpkg.com/viz.js/full.render.js"></script>
  <style>
    body {
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
      font-family: Arial, sans-serif;
    }
    #commands {
      width: 100%;
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #output {
      width: 100%;
      text-align: center;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>Commands2Dot</h1>
  <textarea id="commands" placeholder="ここにコマンドを貼り付けてください" rows="10"></textarea>
  <br>
  <button onclick="processCommands()">描画</button>
  <div id="output"></div>

  <script>
    function generateDot(commands) {
      const model = {
        title: "",
        elements: {},
        relations: [],
      };

      const lines = commands.split(";").map(line => line.trim()).filter(line => line.length > 0);

      lines.forEach(line => {
        const tokens = line.split(" ").filter(token => token.length > 0);
        const command = tokens.shift();

        if (command === "TITLE") {
          model.title = line.slice(7, -1);
        } else if (command === "CREATE") {
          const elements = line.slice(7).split(",");
          elements.forEach(element => {
            const [id, label] = element.trim().split(" ", 2);
            model.elements[id] = label.slice(1, -1);
          });
        } else if (command === "RELATE") {
          const pairs = line.slice(7).split(",");
          pairs.forEach(pair => {
            const [id1, id2] = pair.trim().split(" ");
            model.relations.push({ from: id1, to: id2 });
          });
        } else if (command === "REMOVE") {
          const elementIds = line.slice(7).split(",");
          elementIds.forEach(id => {
            id = id.trim();
            delete model.elements[id];
            model.relations = model.relations.filter(rel => rel.from !== id && rel.to !== id);
          });
        } else if (command === "UNRELATE") {
          const pairs = line.slice(9).split(",");
          pairs.forEach(pair => {
            const [id1, id2] = pair.trim().split(" ");
            model.relations = model.relations.filter(rel => !(rel.from === id1 && rel.to === id2));
          });
        } else if (command === "RENAME") {
          const elements = line.slice(7).split(",");
          elements.forEach(element => {
            const [id, label] = element.trim().split(" ", 2);
            if (model.elements[id]) {
              model.elements[id] = label.slice(1, -1);
            }
          });
        }
      });

      let dotData = `digraph G {
    layout="dot"
    compound=true
    overlap=false
    splines=true
    rankdir="LR"
    ranksep=1.5
    nodesep=0.8
    
    node [shape=box, fontname="Arial", fontsize=20, style="rounded,filled", fillcolor=white]
    edge [fontname="Arial", fontsize=20]
    graph [fontname="Arial", fontsize=20]

    label="${model.title}"
    labelloc="t"
    fontsize=20

    { rank=same; input_rank }
    { rank=same; activity_rank }
    { rank=same; output_rank }
    { rank=same; outcome_rank }
    { rank=same; impact_rank }
    `;

      // 各カテゴリーのランクノードを追加
      dotData += `
    input_rank [style=invis]
    activity_rank [style=invis]
    output_rank [style=invis]
    outcome_rank [style=invis]
    impact_rank [style=invis]

    input_rank -> activity_rank -> output_rank -> outcome_rank -> impact_rank [style=invis]
    `;

      const categories = ["input", "activity", "output", "outcome", "impact"];

      categories.forEach((category, index) => {
        dotData += `subgraph cluster_${category} {
        style="rounded"
        color="#666666"
        label="${category}"
        labeljust="c"
        
        ${category}_rank
        `;

        for (const id in model.elements) {
          if (id.startsWith(category.slice(0, -1))) {
            dotData += `${id} [label="${model.elements[id].split("\\n").join("\\n")}"]\n`;
          }
        }

        dotData += "}\n";
      });

      model.relations.forEach(relation => {
        dotData += `${relation.from} -> ${relation.to}\n`;
      });

      dotData += "}\n";
      return dotData;
    }

    async function renderLogicModel(dotText) {
      try {
        const viz = new Viz();
        const svg = await viz.renderSVGElement(dotText);
        svg.style.maxWidth = '100%';
        svg.style.height = 'auto';
        
        output.innerHTML = '';
        output.appendChild(svg);

        // SVGのviewBox属性を調整して中央に配置
        const bbox = svg.getBBox();
        const padding = 10;
        svg.setAttribute('viewBox', `${bbox.x - padding} ${bbox.y - padding} ${bbox.width + padding*2} ${bbox.height + padding*2}`);
      } catch (error) {
        console.error('Error rendering logic model:', error);
        output.innerHTML = '<p style="color: red;">エラーが発生しました。コマンドの構文を確認してください。</p>';
      }
    }

    async function processCommands() {
      const commands = document.getElementById('commands').value;
      if (!commands.trim()) {
        output.innerHTML = '<p style="color: orange;">コマンドを入力してください。</p>';
        return;
      }
      const dotData = generateDot(commands);
      await renderLogicModel(dotData);
    }
  </script>
</body>
</html>
