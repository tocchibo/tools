<!DOCTYPE html>
<html lang="jp">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ロジックモデル描画</title>
  <script src="https://unpkg.com/viz.js"></script>
  <script src="https://unpkg.com/viz.js/full.render.js"></script>
  <style>
    body {
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    #commands {
      width: 100%;
      margin-bottom: 20px;
    }
    #output {
      width: 100%;
      text-align: center;
    }
    .controls {
      margin-bottom: 20px;
    }
    select {
      padding: 5px;
      margin-right: 10px;
    }
    label {
      margin-right: 5px;
    }
    button {
      padding: 5px 10px;
      margin-right: 10px;
    }
    .copy-success {
      color: green;
      display: none;
      margin-left: 10px;
    }
    /* 非表示のcanvas */
    #tempCanvas {
      display: none;
    }
  </style>
</head>
<body>
  <textarea id="commands" placeholder="ここにチャットボットの回答を貼り付けてください" rows="10" oninput="processCommands()"></textarea>
  <br>
  <div class="controls">
    <label for="splineType">線のスタイル:</label>
    <select id="splineType" onchange="processCommands()">
      <option value="line">直線</option>
      <option value="spline">曲線</option>
    </select>
    
    <label for="edgeType">エッジのスタイル:</label>
    <select id="edgeType" onchange="processCommands()">
      <option value="line">線</option>
      <option value="arrow">矢印</option>
    </select>
    
    <button onclick="clearAll()">クリア</button>
    <button onclick="copyAsPNG()" id="pngButton">画像としてコピー</button>
    <button onclick="copySVG()" id="copyButton">SVGとしてコピー(ppt貼付用)</button>
    <span id="copySuccess" class="copy-success">✓ コピーしました</span>
  </div>
  <div id="output"></div>
  <canvas id="tempCanvas"></canvas>

  <script>
    let lastProcessTime = 0;
    const DEBOUNCE_TIME = 300;

    function showCopySuccess() {
      const successMsg = document.getElementById('copySuccess');
      successMsg.style.display = 'inline';
      setTimeout(() => {
        successMsg.style.display = 'none';
      }, 2000);
    }

    // フォールバックとしてのデータURL作成関数
    function createDataURL(svg) {
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svg);
      const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
      return URL.createObjectURL(svgBlob);
    }

    // レガシーなクリップボードAPIを使用するフォールバック
    function legacyClipboardCopy(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        return document.execCommand('copy');
      } catch (err) {
        console.error('レガシーコピーに失敗:', err);
        return false;
      } finally {
        document.body.removeChild(textarea);
      }
    }

    async function copyAsPNG() {
          const svg = document.querySelector('#output svg');
          if (!svg) {
            alert('ロジックモデルが生成されていません');
            return;
          }

          try {
            const viewBox = svg.viewBox.baseVal;
            const canvas = document.getElementById('tempCanvas');
            const scale = window.devicePixelRatio || 1;
            const padding = 40;

            canvas.width = Math.ceil((viewBox.width + padding * 2) * scale);
            canvas.height = Math.ceil((viewBox.height + padding * 2) * scale);
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const dataUrl = createDataURL(svg);
            
            return new Promise((resolve, reject) => {
              const img = new Image();
              img.onload = async () => {
                try {
                  ctx.drawImage(
                    img,
                    padding * scale,
                    padding * scale,
                    viewBox.width * scale,
                    viewBox.height * scale
                  );

                  // 最新のClipboard APIを試す
                  try {
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    await navigator.clipboard.write([
                      new ClipboardItem({ 'image/png': blob })
                    ]);
                  } catch (err) {
                    // フォールバック: データURLをクリップボードにコピー
                    const dataUrl = canvas.toDataURL('image/png');
                    if (!legacyClipboardCopy(dataUrl)) {
                      // ダウンロードリンクを提供
                      const link = document.createElement('a');
                      link.download = 'logic-model.png';
                      link.href = dataUrl;
                      link.click();
                      alert('クリップボードへのコピーができませんでした。画像をダウンロードします。');
                    }
                  }

                  showCopySuccess();
                  resolve();
                } catch (err) {
                  reject(err);
                } finally {
                  URL.revokeObjectURL(dataUrl);
                }
              };
              img.onerror = () => {
                URL.revokeObjectURL(dataUrl);
                reject(new Error('画像の読み込みに失敗しました'));
              };
              img.src = dataUrl;
            });
          } catch (err) {
            console.error('PNGの生成に失敗しました:', err);
            alert('PNGの生成とコピーに失敗しました');
          }
        }

        async function copySVG() {
      const svg = document.querySelector('#output svg');
      if (!svg) {
        alert('ロジックモデルが生成されていません');
        return;
      }

      try {
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svg);
        
        try {
          // 最新のClipboard APIを試す
          const blob = new Blob([svgString], {type: 'image/svg+xml'});
          await navigator.clipboard.write([
            new ClipboardItem({ 'image/svg+xml': blob })
          ]);
        } catch (err1) {
          try {
            // テキストとしてのコピーを試す
            await navigator.clipboard.writeText(svgString);
          } catch (err2) {
            // レガシーなクリップボードAPIを使用
            if (!legacyClipboardCopy(svgString)) {
              // ダウンロードリンクを提供
              const dataUrl = createDataURL(svg);
              const link = document.createElement('a');
              link.download = 'logic-model.svg';
              link.href = dataUrl;
              link.click();
              URL.revokeObjectURL(dataUrl);
              alert('クリップボードへのコピーができませんでした。SVGをダウンロードします。');
              return;
            }
          }
        }
        
        showCopySuccess();
      } catch (err) {
        console.error('SVGのコピーに失敗しました:', err);
        alert('SVGのコピーに失敗しました');
      }
    }

    function generateDot(commands) {
      const model = {
        title: "",
        elements: {},
        relations: [],
      };

      const lines = commands.split(";").map(line => line.trim()).filter(line => line.length > 0);

      lines.forEach(line => {
        const tokens = line.split(" ").filter(token => token.length > 0);
        const command = tokens.shift();

        if (command === "TITLE") {
          model.title = line.slice(7, -1);
        } else if (command === "CREATE") {
          const elements = line.slice(7).split(",");
          elements.forEach(element => {
            const [id, label] = element.trim().split(" ", 2);
            model.elements[id] = label.slice(1, -1);
          });
        } else if (command === "RELATE") {
          const pairs = line.slice(7).split(",");
          pairs.forEach(pair => {
            const [id1, id2] = pair.trim().split(" ");
            model.relations.push({ from: id1, to: id2 });
          });
        } else if (command === "REMOVE") {
          const elementIds = line.slice(7).split(",");
          elementIds.forEach(id => {
            id = id.trim();
            delete model.elements[id];
            model.relations = model.relations.filter(rel => rel.from !== id && rel.to !== id);
          });
        } else if (command === "UNRELATE") {
          const pairs = line.slice(9).split(",");
          pairs.forEach(pair => {
            const [id1, id2] = pair.trim().split(" ");
            model.relations = model.relations.filter(rel => !(rel.from === id1 && rel.to === id2));
          });
        } else if (command === "RENAME") {
          const elements = line.slice(7).split(",");
          elements.forEach(element => {
            const [id, label] = element.trim().split(" ", 2);
            if (model.elements[id]) {
              model.elements[id] = label.slice(1, -1);
            }
          });
        }
      });

      const splineType = document.getElementById('splineType').value;
      const edgeType = document.getElementById('edgeType').value;

      let dotData = `digraph G {
    graph [
        fontname="Arial"
        splines="${splineType}"
        rankdir="LR"
        center=true
    ];
    node [
        fontname="Arial"
        shape="box"
        style="filled"
        fillcolor="white"
    ];
    edge [fontname="Arial"${edgeType === "line" ? ", arrowhead=none" : ""}];

    label="${model.title}";
    labelloc="t";
    fontsize=24;

    `;

      const categories = ["input", "activity", "output", "outcome", "impact"];

      categories.forEach(category => {
        dotData += `subgraph cluster_${category} {
    style="filled";
    color="transparent";
    fillcolor="#f5f5f5";
    label="${category}"\n`;

        for (const id in model.elements) {
          if (id.startsWith(category.slice(0, -1))) {
            dotData += `${id} [label="${model.elements[id].split("\\n").join("\\n")}"]\n`;
          }
        }

        dotData += "}\n";
      });

      model.relations.forEach(relation => {
        dotData += `${relation.from} -> ${relation.to}\n [tailport = e, headport = w]`;
      });

      dotData += "}\n";

      return dotData;
    }

    async function renderLogicModel(dotText) {
      try {
        const viz = new Viz();
        const svg = await viz.renderSVGElement(dotText);
        svg.style.maxWidth = '100%';
        output.innerHTML = '';
        output.appendChild(svg);
      } catch (error) {
        console.error('Error rendering logic model:', error);
        output.innerHTML = '<p style="color: red;">エラーが発生しました</p>';
      }
    }

    async function processCommands() {
      const currentTime = Date.now();
      if (currentTime - lastProcessTime < DEBOUNCE_TIME) {
        return;
      }
      lastProcessTime = currentTime;

      const commands = document.getElementById('commands').value;
      if (commands.trim() === '') {
        document.getElementById('output').innerHTML = '';
        return;
      }
      const dotData = generateDot(commands);
      await renderLogicModel(dotData);
    }

    function clearAll() {
      document.getElementById('commands').value = '';
      document.getElementById('output').innerHTML = '';
    }
  </script>
</body>
</html>
